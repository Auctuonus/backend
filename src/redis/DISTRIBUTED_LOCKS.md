# Распределенные блокировки (Distributed Locks)

## Обзор

`DistributedLockService` использует **Pub/Sub подход** для эффективной работы с распределенными блокировками.

### ✅ Преимущества:
- **Минимальная нагрузка на Redis** - только при освобождении блокировки
- **Мгновенное уведомление** всех ожидающих процессов
- **Масштабируется** на тысячи ожидающих процессов
- **Гарантированное выполнение** запроса (если блокировка освобождается в пределах таймаута)

## Использование

### Простой случай

```typescript
// Использует Pub/Sub с таймаутом 30 секунд по умолчанию
await this.lockService.withLock('auction:123', async () => {
  // Критическая секция
  await this.processAuction();
});
```

### С настройками таймаута

```typescript
await this.lockService.withLock(
  'auction:123',
  async () => {
    await this.processAuction();
  },
  {
    timeoutMs: 60000,    // 60 секунд максимум ожидания
    maxAttempts: 2000,   // максимум 2000 попыток
  }
);
```

## Прямое использование методов

### Ручное управление блокировками

```typescript
const token = await this.lockService.acquireLockWithPubSub('auction:123', {
  timeoutMs: 30000,
  maxAttempts: 1000,
});

try {
  // Критическая секция
  await this.processAuction();
} finally {
  await this.lockService.releaseLock('auction:123', token);
}
```

### Проверка наличия блокировки

```typescript
const isLocked = await this.lockService.isLocked('auction:123');
if (isLocked) {
  // Ресурс заблокирован
}
```

## Как это работает под капотом

### Pub/Sub механизм:

1. При запуске сервиса создаются два Redis клиента:
   - `REDIS_PUBLISHER` - для публикации событий
   - `REDIS_SUBSCRIBER` - для подписки на события

2. Subscriber подписывается на канал `lock:released:*`

3. При попытке получить занятую блокировку:
   - Процесс подписывается на событие освобождения через EventEmitter
   - Ждет события с таймаутом (по умолчанию 5 секунд)
   - При получении события сразу повторяет попытку
   - При таймауте также повторяет попытку (на случай потери события)

4. При освобождении блокировки:
   - Публикуется событие в Redis: `lock:released:${key}`
   - Все подписчики мгновенно получают уведомление
   - Процессы конкурируют за получение блокировки

## Эффективность Pub/Sub

### Пример: 100 процессов ожидают блокировку 10 секунд

**С Pub/Sub:**
- 1 подписка × 100 процессов = 100 операций при старте
- 1 публикация при освобождении
- ~100 попыток получить блокировку после уведомления
- **Итого: ~200 операций**

**Традиционный polling (для сравнения):**
- 100 процессов × 100 проверок в секунду × 10 сек = **100,000 операций**

**Выигрыш: в 500 раз меньше нагрузки на Redis!**

## Метрики

Сервис собирает метрики:

```typescript
const metrics = this.lockService.getMetrics();
console.log(metrics);
// {
//   acquired: 150,
//   released: 148,
//   failed: 2,
//   totalWaitTimeMs: 5240,
//   avgWaitTimeMs: 34.93
// }
```

## Рекомендации

1. **Устанавливайте адекватные таймауты** - 30-60 секунд для большинства случаев
2. **Мониторьте метрики** - высокий `avgWaitTimeMs` может указывать на проблемы
3. **Используйте короткие ключи** - они эффективнее в Redis
4. **Проверяйте критические секции** - убедитесь, что они не выполняются слишком долго

## TODO

- [ ] Добавить TTL (time-to-live) для автоматического освобождения блокировок
- [ ] Добавить Redlock алгоритм для multi-master конфигурации Redis
- [ ] Добавить автоматическое продление блокировок для длительных операций
- [ ] Добавить мониторинг через Prometheus
